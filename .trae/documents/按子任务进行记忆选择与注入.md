## 现状诊断
- 你现在的“记忆缓存”机制主要在对话开始阶段做一次选择：把候选记忆（skill/readReference/call）通过选择器挑出来，然后注入到基础上下文里。
- 这很好，但它是“全局一次性注入”，对子任务执行阶段缺少“按需加载/按需关联”的判断，因此会出现两类问题：
  - 子任务之间不相关时，仍携带无关记忆 → 上下文噪声变大、token 浪费、推理偏航。
  - 子任务之间相关时，没有自动把“上一子任务结果/必要技能记忆”带上 → 模型像失忆，重复问/重复调用。

## 更像人的记忆模型（建议标准）
把记忆分成 3 类，并建立“注入标准/预算/缓存命中规则”：
- **程序性记忆（Procedural）**：技能描述（read）+ 使用规范（你现在的 SKILL.md）
  - 适用：当子任务需要用某个技能或某类工具时。
  - 标准：若子任务要用 skill X，则至少注入 X 的 read；若选中了 X 的 reference/call，也必须带上 X 的 read（你已在 selector 里加了这个规则）。
- **语义记忆（Semantic）**：参考文件（readReference）
  - 适用：子任务涉及某个固定规范/文档/接口说明。
  - 标准：只有当子任务文本或实体识别命中该 reference（文件名/主题/关键词）才注入。
- **情景记忆（Episodic）**：脚本调用结果（call）+ 你每个子任务的中间结论/产物
  - 适用：后续子任务要复用上一步结果（例如上一任务拿到了 diff、文件列表、配置值等）。
  - 标准：只有当子任务对“实体/产物”有依赖时注入（见下文“关联判断”）。

### 子任务关联判断（给一个可执行标准）
建议采用“规则优先 + 模型兜底”的两阶段：
1) **规则/实体判断（快且稳定）**
- 共享实体则认为相关：同 repoUrl/branch/filename、同 skill、同 script、同 reference、同业务关键词（可做简单词表/正则）。
- 依赖链判断：如果 planner 标注了 dependsOn=[…]，则默认相关。
2) **LLM 关联判定（慢但更聪明）**
- 当规则判断不确定时，让一个轻量 selector 只回答：是否需要引用“已完成子任务结果 A/B/C”与“哪些 skill 记忆”。

### 预算与缓存命中（避免上下文爆炸）
- 每个子任务有一个“工作集 working set”，上限例如 2~5 条记忆（read + 必要 reference/call + 必要上一步结果）。
- 对已注入过的记忆做“命中缓存”：同一子任务内不要重复注入同 key；跨子任务可按策略复用（比如同 skill 连续子任务不重复注入全文，而注入一段摘要或只注入一次并在系统提示词中声明“已在上文加载”）。
- 对“子任务结果”做滚动摘要：保留最近 K 个完整结果，其余压缩为一段“已完成工作摘要”。

## 方案落地（不写代码前提下的实现路径）
### 1) 让 planner 输出更结构化的子任务
- 把 task 拆解从 string[] 升级为 Task[]：
  - title
  - dependsOn（依赖哪些子任务）
  - suggestedSkills（可能用到哪些技能）
  - deliverable（期望产物：例如文件列表/diff/最终建议）
- 这样“关联判断”大部分可以不用再猜。

### 2) 子任务执行前增加“记忆选择阶段”
- 在每个子任务执行前，调用一个 memory selector：输入=（历史上下文摘要 + 当前子任务 + 已完成子任务摘要 + 候选记忆列表），输出=需要注入的 memory keys。
- 注入顺序建议：
  1) 当前子任务依赖的已完成子任务结果（episodic）
  2) 所需 skill read（procedural）
  3) 必要 reference/call（semantic/episodic）

### 3) 把“子任务结果”也纳入记忆体系
- 每个子任务完成后，把结果写入“任务记忆”（只在运行时保存即可，不一定落盘）：
  - key=taskIndex/title
  - snippet=一句话概述
  - content=结构化结果（或 markdown）
  - meta=关联实体（repoUrl、filename、skill等）
- 下一子任务选择记忆时，把这些任务记忆也作为候选。

### 4) 在系统提示词中固化规则
- 增加一段“记忆使用原则”：
  - 仅在与当前子任务相关时加载记忆
  - 选择到 reference/call 必须带上对应 skill read
  - 已在对话中“捞取到记忆缓存”的内容视为已加载，避免重复

## 验证方式
- 用两个强对比场景验证：
  1) 明显独立的两个子任务（应不互相注入记忆，token 明显下降）
  2) 强依赖链子任务（应自动带上上一步结果与必要技能记忆，减少重复工具调用）

## 需要你确认的一个取舍
- 你更希望“严格最小上下文”（省 token、但可能偶发遗漏）还是“保守多带一点”（更稳但更贵）？我建议先做“规则优先 + LLM 兜底 + 工作集上限”的折中策略。