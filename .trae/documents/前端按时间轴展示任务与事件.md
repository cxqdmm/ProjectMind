## 问题定位
- 目前任务卡片是独立于 `m.content` 渲染的（在内容循环之前固定渲染），导致它**永远显示在对话内容最上方**，不管 task_list 事件实际何时到达。
- 同类问题还存在于“子任务展开区内部顺序”：现在是先展示结果，再展示记忆/工具，这与真实执行顺序（工具/记忆先发生，结果最后产生）不一致。

## 目标
- 对话内容（含 task、工具、记忆、文本）按**事件到达/发生的时间顺序**从上到下展示。
- 子任务展开详情内，也按更符合阅读习惯的顺序展示（工具/记忆 → 结果）。

## 改造方案（不改变后端，仅改前端展示）

### 1) 把“任务卡片”变成消息内容的一种 part（时间轴化）
- 在 SSE 收到 `task_list` 时：
  - 仍然写入 `messages[idx].tasks = normalizeTasks(...)`（用于实时更新 task 状态）
  - **同时往 `messages[idx].content` 里 push 一个 part**：`{ type: 'tasks', timestamp: Date.now() }`
  - 为避免重复插入，在 message 上挂一个标记：`messages[idx].__tasks_part_added = true`
- 在 SSE 收到 `task_update` 时：
  - upsert 更新 `messages[idx].tasks`
  - 若 `__tasks_part_added` 还没置位（兼容 task_update 先到），先插入 `{type:'tasks'}` 再更新。

### 2) 调整模板渲染顺序
- 删除当前固定渲染的 `m.tasks` 顶部块（就是你看到“tasks 模块总在最上方”的根因）。
- 在 `v-for (part in m.content)` 内新增一个分支：
  - `v-else-if="part.type === 'tasks'"`：在**时间轴位置**渲染任务卡片（数据源使用 `m.tasks`，保证 task_update 实时刷新）。

### 3) 优化“子任务详情”的内部顺序（更像时间先后）
- 当前：结果 → 记忆 → 工具
- 调整为：工具 → 记忆 → 结果（或 工具 → 记忆 → 错误 → 结果）
  - 这样用户从上往下读：先看到过程（调用了什么技能/命中什么记忆），再看到产出。

### 4) 顺带检查其它可能的先后问题
- `tool_calls/tool_update`：目前是按事件到达 push 到 `m.content`，且工具视图内部会按 timestamp/startTime 排序，整体可接受。
- `memory_used`：已按 push 顺序渲染；将继续保持按时间显示。
- token 面板不属于对话时间轴，不调整。

## 验证方式
- 造两种时序：
  1) assistant 先输出几段文本，再收到 task_list：任务卡片应出现在文本之后。
  2) task_update 先于 task_list：仍能插入任务卡片且不丢更新。
- 运行 `frontend npm run build` 确保无模板/类型错误。

## 交付物
- 仅修改 [frontend/src/App.vue](file:///Users/mac/Documents/cxq/工作/ProjectMind/frontend/src/App.vue) 的 SSE 处理与模板结构，确保各种信息按时间轴展示。