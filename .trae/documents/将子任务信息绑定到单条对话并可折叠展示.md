## 目标
- 子任务信息不再是全局唯一面板，而是“绑定到本次 assistant 回复消息”里展示。
- 新对话开始时不会覆盖旧对话的子任务；历史对话仍在页面中可回看。

## 前端数据结构调整（App.vue）
- 在 `messages` 的每条 assistant 消息对象上增加 `tasks` 字段（数组），用于保存该轮对话的子任务快照。
- 子任务折叠状态不再用全局 `openTaskIds`，改复用现有 `openIds`，通过前缀区分（例如 `task::<taskId>`），避免额外全局状态。

## SSE 事件归属到当前消息
- 在 `onSend()` 的 SSE 解析中：
  - `task_list`：写入 `messages[idx].tasks = normalizeTasks(data.tasks)`
  - `task_update`：对 `messages[idx].tasks` 做 upsert（按 `task.id` 或 `task.index`）
- 移除当前用于右侧面板的全局变量：`tasks/taskVisible/openTaskIds`，避免“新对话覆盖旧对话”。
- 移除 `debugger` 语句，防止浏览器调试断点影响体验。

## UI 渲染改造
- 把子任务面板从右侧浮层移到“每条 assistant 消息内部”的一个卡片区块：
  - 标题：子任务 + 数量
  - 列表：序号、标题、状态（待执行/进行中/已完成/失败）、展开/收起按钮
  - 展开内容：优先显示 `result`，失败显示 `error`，否则显示“暂无结果”
- 卡片位置建议：在该 assistant 消息内容区域顶部（在 markdown/text/tool/memory 之前），保证和本轮对话关联清晰。

## 样式与布局
- 删除或隐藏右侧 `task-panel` 样式及布局（保留 token 面板不动）。
- 为消息内 task 卡片补充一套更紧凑的样式（宽度随消息内容，自然换行，默认不遮挡）。

## 验证
- 发起两轮对话：
  1) 第一轮触发子任务（能看到子任务卡片在第一条 assistant 消息里）
  2) 第二轮再触发另一组子任务（应只出现在第二条 assistant 消息里，第一轮仍保留可展开结果）
- 确认 `task_update` 会实时更新对应子任务状态/结果。

## 兼容性处理
- `task_update` 可能先于 `task_list` 到达：做一个“若 tasks 为空则先创建容器”的兜底。
- `task.id` 可能缺失：回退用 `index` 作为 key。