## 问题定位
- 目前子任务卡片是基于 `m.tasks` 在消息内容区顶部固定渲染（不在 `m.content` 的事件流里）。
- 这会导致“tasks 模块永远出现在最上方”，即使它实际是在对话中途才产生，违反时间顺序阅读。

## 目标
- 让同一条 assistant 消息里的所有信息（文本片段、tool_calls/tool_update、memory_used、task_list/task_update、最终 done 文本）都按产生顺序从上到下渲染。
- 不破坏现有归档：任务下挂的工具/记忆仍能在该任务折叠区查看。

## 方案核心：把子任务也变成 content 事件
### 1) 在 SSE 解析时写入“任务事件”到 `messages[idx].content`
- 当收到 `task_list`：
  - 仍更新 `messages[idx].tasks = normalizeTasks(...)`
  - 同时向 `messages[idx].content` 追加一个 part：`{ type: 'tasks', timestamp, kind: 'task_list' }`
- 当收到 `task_update`：
  - 仍 upsert 到 `messages[idx].tasks`
  - 若尚未插入过 `type:'tasks'` 的 part，则插入一次（时间戳为当前）；否则不重复插入（避免刷屏）
  - 可选：也追加 `kind:'task_update'` 的轻量 part（只显示“任务状态变更”），但我建议默认不追加，避免每次 update 都占一行。

### 2) 在模板中移除“固定顶部 tasks 卡片”
- 删除当前 `m.role==='assistant' && m.tasks` 的顶部 task-card 区块。
- 在 `v-for (part in m.content)` 的分支里新增：
  - `v-else-if="part.type === 'tasks'"`：渲染任务卡片（用 `m.tasks` 的实时状态 + 你现有的任务折叠 UI + 任务下的工具/记忆）。
- 这样 tasks 卡片就会出现在它第一次出现（task_list 到达）的时间位置。

## 其他“先后问题”顺手校验与优化点
- **memory_used/tool_calls/tool_update**：目前已经按到达顺序 push 到 `m.content`，展示顺序是正确的；保持不动。
- **task 归档的工具/记忆**：属于“任务内部详情”，展开后看到即可，不需要参与全局时间轴；保持不动。
- **done 文本**：仍在最后追加到 `m.content`，顺序正确。

## 兼容与边界处理
- 如果 `task_update` 先于 `task_list` 到达：
  - `ensureTaskInMessage` 已能兜底创建 task；
  - 同时插入一次 `type:'tasks'` part，让 UI 仍能在时间线上出现。
- 如果一个消息里没有任务：不插入任何 tasks part。

## 验证方式
- 触发一次包含子任务的对话：确认 tasks 卡片出现在 tool/memory 之后或之前的正确位置（以 SSE 到达顺序为准）。
- 连续触发两轮对话：两条 assistant 消息各自的时间线独立，且各自任务卡片位置正确。
- 确认任务折叠内仍能看到该任务归档的工具与记忆。

## 影响文件
- 前端：`frontend/src/App.vue`（SSE 解析 + 模板渲染逻辑）。
- 后端无需改动。