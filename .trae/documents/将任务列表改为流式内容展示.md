我将修改 `frontend/src/composables/useAgentStream.js` 文件，改变 `task_list` 事件的处理逻辑。

**当前问题**：
`task_list` 事件目前会直接覆盖消息对象上的 `m.tasks` 属性。如果后端分多次发送任务列表（例如追加 Followup 任务），旧的任务列表会被新的覆盖，导致前端丢失之前的任务展示。

**修改计划**：
1.  **废弃 `m.tasks` 属性**：不再将任务列表存储在消息对象的根属性 `m.tasks` 上。
2.  **作为 `content` 的一部分**：
    *   当收到 `task_list` 事件时，将其包装为一个 `{ type: 'tasks', tasks: [...] }` 对象。
    *   直接 `push` 到 `messages.value[idx].content` 数组中。
    *   这样，每次收到的任务列表都会按照时间顺序作为对话流的一部分被渲染，互不干扰，也不会覆盖。
3.  **兼容性调整**：
    *   更新 `ensureTasksPart` 和 `upsertTaskIntoMessage` 等辅助函数，使其能够定位到最近的一个 `type: 'tasks'` 内容块进行更新，或者在找不到时追加新的块。
    *   确保后续的 `task_update` 事件能够正确更新到对应的任务列表块中。

**具体实现细节**：
*   **收到 `task_list`**：直接 `arr.push({ type: 'tasks', tasks: normalizeTasks(data.tasks), timestamp: Date.now() })`。
*   **收到 `task_update`**：
    *   遍历 `content` 数组，找到**最近的一个** `type: 'tasks'` 块。
    *   在该块的 `tasks` 列表中查找并更新对应的任务状态。
    *   如果找不到，则创建一个新的 `tasks` 块并追加。

这样修改后，任务列表将成为流式对话的一部分，自然地支持多轮任务规划和展示。