## 目标
- 前端能在“某个子任务”下面看到：该子任务触发的工具调用（含状态/输入/输出）与记忆命中（memory_used），形成清晰的“任务 → 技能/工具 → 记忆”关系。
- 不再把工具/记忆作为“整条对话的全局事件”展示，避免看不出归属。

## 总体思路
- **后端在 SSE 事件里携带 task 上下文**（taskId/taskIndex/title）。
- **前端按 task 上下文把 tool_calls/tool_update/memory_used 事件归档到对应 task**，并在该 task 的折叠区域中渲染。
- 兼容：没有 task 上下文的事件仍按原方式展示在消息级别（例如初始 memory_used）。

## 后端改造（agentService.js）
### 1) 引入“当前子任务上下文”
- 在 `runSingleTask(...)` 中拿到 `inProg` 后，构造：
  - `const taskCtx = { id: inProg.id, index: inProg.index, title: inProg.title }`
- 之后把 `taskCtx` 作为参数传递给：
  - `selectTaskMemoryMessages(...)`（memory_used 归属当前 task）
  - `runTaskToolLoop(...)`（tool_calls 归属当前 task）
  - `drainToolQueue/execSingleToolCall(...)`（tool_update 归属当前 task）

### 2) 让 SSE 事件带 task 字段
- `ctx.emit({ type: 'tool_calls', calls: prepared, task: taskCtx })`
- `ctx.emit({ type: 'tool_update', ..., task: taskCtx })`
- `ctx.emit({ type: 'memory_used', memories: ..., task: taskCtx })`
- `task_list/task_update` 已经包含 task 对象，无需额外字段（可选：也可补 taskCtx 以统一）。

### 3) 约束哪些 memory_used 属于 task
- `buildBaseMessages` 的 memory_used（初始记忆选择）不带 task：属于“消息级别/全局”。
- `selectTaskMemoryMessages` 的 memory_used 带 task：属于“子任务级别”。

## 前端改造（App.vue）
### 1) 扩展 message.tasks 数据结构
- 每个 task 除了现有字段（id/index/title/status/result/error），新增：
  - `toolEvents: []`（存 tool_calls/tool_update 的事件流）
  - `memories: []`（存 memory_used 的 memories 数组）
- 更新 task 时保留已有 `toolEvents/memories`，避免被覆盖。

### 2) SSE 事件归档逻辑
- `task_list`：初始化 `messages[idx].tasks = normalizeTasks(...)`，并补上 `toolEvents/memories` 空数组。
- `task_update`：upsert task（保留原 task 的 `toolEvents/memories`）。
- `tool_calls/tool_update`：
  - 如果 `data.task?.id` 存在：定位 `messages[idx].tasks` 中对应 task，push 到该 task 的 `toolEvents`。
  - 否则：按现有逻辑 push 到 `messages[idx].content`，作为“消息级别工具调用”。
- `memory_used`：
  - 如果 `data.task?.id` 存在：合并到对应 task 的 `memories`（按 key 去重）。
  - 否则：保持现状 push 到 `messages[idx].content`，作为“消息级别记忆”。

### 3) UI 渲染（任务折叠区内挂载工具与记忆）
- 在每个 task 的展开区域增加两个块：
  - **工具调用**：用现有的工具展示 UI（tool-events/tool-row）渲染 `task.toolEvents` 计算得到的 batches。
  - **记忆缓存**：直接复用 `MemoryUsedList`，传 `:memories="task.memories"`。
- 交互：沿用当前折叠机制；工具的“展开/收起”可继续复用 `openIds`。

## 数据匹配与边界处理
- tool_update 事件按 call.id 回填到 tool_calls 的 batch 中：沿用现有 `buildToolView` 思路，但输入源改为 `task.toolEvents`。
- 防御：如果 tool_update 先到而 tool_calls 未到，先缓存事件，后续 tool_calls 到了再合并。
- 如果后端未带 task 字段，前端仍按旧逻辑展示（不破坏现有功能）。

## 验证
- 本地触发一次包含 2+ 子任务、每个子任务含工具调用与记忆选择的对话。
- 期望：
  - 每个子任务下能看到自己的工具调用列表与对应的记忆条目
  - 消息级别（非 task）的 memory_used 仍能显示（例如初始记忆）
  - 新一轮对话不会覆盖旧对话的任务/工具/记忆归档

## 影响范围
- 后端：agentService.js（emit 结构变化，向后兼容）
- 前端：App.vue（SSE 解析与 task UI 增强，复用现有组件与样式）